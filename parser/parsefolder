#!/usr/bin/env python3
"""
ChordPro Folder Parser

Simple CLI for parsing entire language folders using the improved universal parser.
Usage: chordprofolder <language_code>

Examples:
  chordprofolder sl    # Parse all Slovenian PDFs
  chordprofolder hr    # Parse all Croatian PDFs
  chordprofolder de    # Parse all German PDFs
"""

import argparse
import logging
import sys
import os
from pathlib import Path
from typing import Optional, List
from datetime import datetime

# Add the parser directory to Python path
parser_dir = Path(__file__).parent
sys.path.insert(0, str(parser_dir))

try:
    from parsers.improved_universal_parser import ImprovedUniversalParser
    from languages.slovenian.config import SlovenianConfig
    from languages.croatian.config import CroatianConfig
    from languages.spanish.config import SpanishConfig
    from languages.italian.config import ItalianConfig
except ImportError as e:
    print(f"‚ùå Import error: {e}")
    print("Make sure you're running this from the correct directory")
    sys.exit(1)


def setup_logging(verbose: bool = False, debug: bool = False) -> None:
    """Setup logging configuration"""
    if debug:
        level = logging.DEBUG
    elif verbose:
        level = logging.INFO
    else:
        level = logging.WARNING

    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%H:%M:%S'
    )

    # Reduce noise from some modules
    logging.getLogger('fitz').setLevel(logging.WARNING)


def get_language_config(language_code: str):
    """Get language configuration for the given language code"""
    language_map = {
        'sl': SlovenianConfig,
        'slovenian': SlovenianConfig,
        'hr': CroatianConfig,
        'croatian': CroatianConfig,
        'es': SpanishConfig,
        'spanish': SpanishConfig,
        'it': ItalianConfig,
        'italian': ItalianConfig,
        # Add more languages as they're implemented
        # 'de': GermanConfig,
    }
    
    config_class = language_map.get(language_code.lower())
    if not config_class:
        available = ', '.join(language_map.keys())
        raise ValueError(f"Unsupported language: {language_code}. Available: {available}")
    
    return config_class()


def find_project_root() -> Path:
    """Find the project root directory (contains both 'lang' and 'parser' folders)"""
    current = Path(__file__).parent
    
    # Go up until we find a directory with both 'lang' and 'parser'
    while current.parent != current:  # Not at filesystem root
        if (current / 'lang').exists() and (current / 'parser').exists():
            return current
        current = current.parent
    
    # If not found, assume we're in the parser directory and go up one level
    project_root = Path(__file__).parent.parent
    if (project_root / 'lang').exists():
        return project_root
    
    raise FileNotFoundError("Could not find project root with 'lang' and 'parser' directories")


def get_language_paths(language_code: str) -> tuple[Path, Path]:
    """Get input and output paths for a language"""
    project_root = find_project_root()
    
    lang_dir = project_root / 'lang' / language_code
    pdf_dir = lang_dir / '03_pdf'
    chordpro_dir = lang_dir / '04_chordpro'
    
    if not pdf_dir.exists():
        raise FileNotFoundError(f"PDF directory not found: {pdf_dir}")
    
    # Create output directory if it doesn't exist
    chordpro_dir.mkdir(parents=True, exist_ok=True)
    
    return pdf_dir, chordpro_dir


def find_pdf_files(pdf_dir: Path, language_code: str) -> List[Path]:
    """Find all PDF files for the language"""
    # Look for files with the naming pattern: LANG - NNN.pdf
    pattern = f"{language_code.upper()} - *.pdf"
    pdf_files = list(pdf_dir.glob(pattern))
    
    if not pdf_files:
        # Fallback to any PDF files
        pdf_files = list(pdf_dir.glob("*.pdf"))
    
    return sorted(pdf_files)


def sanitize_filename(title: str) -> str:
    """Sanitize song title for use in filename"""
    import re
    # Remove or replace problematic characters
    sanitized = re.sub(r'[<>:"/\\|?*]', '', title)  # Remove invalid filename chars
    sanitized = re.sub(r'\s+', ' ', sanitized)  # Normalize whitespace
    sanitized = sanitized.strip()

    # Limit length to avoid filesystem issues
    if len(sanitized) > 100:
        sanitized = sanitized[:100].strip()

    return sanitized


def extract_chords_from_song(song) -> list:
    """Extract unique chords from a song"""
    chords = set()
    for verse in song.verses:
        for line in verse.lines:
            for chord in line.chords:
                chords.add(chord.chord)
    return sorted(list(chords))


def create_summary_log(chordpro_dir: Path, language_code: str) -> Path:
    """Create timestamped summary log file"""
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_file = chordpro_dir / f"{language_code.upper()}_parsing_summary_{timestamp}.log"

    # Always create new header for timestamped file
    with open(log_file, 'w', encoding='utf-8') as f:
        f.write(f"# {language_code.upper()} Parsing Summary Log\n")
        f.write(f"# Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
        f.write(f"# Timestamp: {timestamp}\n")
        f.write("# Format: FILENAME | TITLE | ROLES | VERSES | CHORDS\n")
        f.write("-" * 80 + "\n")

    return log_file


def _insert_processing_summary_to_log(log_file: Path, processed: int, skipped: int, failed: int, output_dir: Path):
    """Insert processing summary into log file before the Format line"""
    # Read the current log file content
    with open(log_file, 'r', encoding='utf-8') as f:
        lines = f.readlines()

    # Find where to insert the processing summary (before the "# Format:" line)
    format_line_index = -1
    for i, line in enumerate(lines):
        if line.startswith("# Format: FILENAME"):
            format_line_index = i
            break

    if format_line_index == -1:
        # Fallback: append at the end
        with open(log_file, 'a', encoding='utf-8') as f:
            f.write("\nüìä Processing Summary:\n")
            f.write(f"   ‚úÖ Processed: {processed} files\n")
            if skipped > 0:
                f.write(f"   ‚è≠Ô∏è  Skipped: {skipped} files (use --force to overwrite)\n")
            if failed > 0:
                f.write(f"   ‚ùå Failed: {failed} files\n")
            f.write(f"   üìÅ Output directory: {output_dir}\n")
        return

    # Insert processing summary before the Format line
    summary_lines = [
        "üìä Processing Summary:\n",
        f"   ‚úÖ Processed: {processed} files\n"
    ]
    if skipped > 0:
        summary_lines.append(f"   ‚è≠Ô∏è  Skipped: {skipped} files (use --force to overwrite)\n")
    if failed > 0:
        summary_lines.append(f"   ‚ùå Failed: {failed} files\n")
    summary_lines.append(f"   üìÅ Output directory: {output_dir}\n")

    # Insert the summary before the Format line
    new_lines = lines[:format_line_index] + summary_lines + lines[format_line_index:]

    # Write back to file
    with open(log_file, 'w', encoding='utf-8') as f:
        f.writelines(new_lines)


def process_language_folder(language_code: str, verbose: bool = False, force: bool = False, debug: bool = False, limit: Optional[int] = None) -> int:
    """Process all PDFs in a language folder"""
    try:
        # Get language configuration
        config = get_language_config(language_code)
        parser = ImprovedUniversalParser(config)
        
        # Get paths
        pdf_dir, chordpro_dir = get_language_paths(language_code)
        
        # Find PDF files
        pdf_files = find_pdf_files(pdf_dir, language_code)

        if not pdf_files:
            print(f"‚ùå No PDF files found in {pdf_dir}")
            return 1

        # Apply limit if specified
        if limit is not None and limit > 0:
            pdf_files = pdf_files[:limit]
            print(f"üéµ Processing first {len(pdf_files)} PDF files for language '{language_code.upper()}' (limited from {len(find_pdf_files(pdf_dir, language_code))} total)")
        else:
            print(f"üéµ Processing {len(pdf_files)} PDF files for language '{language_code.upper()}'")

        print(f"üìÅ Input:  {pdf_dir}")
        print(f"üìÅ Output: {chordpro_dir}")
        print()

        # Create summary log
        summary_log = create_summary_log(chordpro_dir, language_code)
        print(f"üìä Summary log: {summary_log}")
        print()

        processed = 0
        skipped = 0
        failed = 0
        
        for pdf_file in pdf_files:
            try:
                print(f"üéµ Processing: {pdf_file.name}")

                # Parse the PDF first to get the title
                song = parser.parse(str(pdf_file))

                # Create filename with title: "HR - 001 - SONG_TITLE.chordpro"
                sanitized_title = sanitize_filename(song.title)
                if sanitized_title and sanitized_title != "Untitled Song":
                    chordpro_filename = f"{pdf_file.stem} - {sanitized_title}.chordpro"
                else:
                    chordpro_filename = f"{pdf_file.stem}.chordpro"

                chordpro_file = chordpro_dir / chordpro_filename

                # Skip if output exists and not forcing
                if chordpro_file.exists() and not force:
                    if verbose:
                        print(f"   ‚è≠Ô∏è  Skipping (output exists): {chordpro_file.name}")
                    skipped += 1
                    continue

                # Export to ChordPro
                chordpro_content = parser.export_chordpro(song)

                # Save to file
                with open(chordpro_file, 'w', encoding='utf-8') as f:
                    f.write(chordpro_content)

                # Extract chords for summary
                chords_used = extract_chords_from_song(song)
                chords_str = ', '.join(chords_used) if chords_used else 'none'

                # Calculate roles and verses counts
                roles_count = len(song.verses)  # Number of role markers (K., Z., etc.)
                verses_count = sum(len(verse.lines) for verse in song.verses)  # Total verse lines

                # Log to summary file
                with open(summary_log, 'a', encoding='utf-8') as f:
                    f.write(f"{chordpro_file.name} | {song.title} | {roles_count} roles | {verses_count} verses | {chords_str}\n")

                print(f"   ‚úÖ Saved: {chordpro_file.name}")
                print(f"   üìä Title: {song.title}")
                print(f"   üìä Roles: {roles_count}")
                print(f"   üìä Verses: {verses_count}")
                print(f"   üìä Chords: {chords_str}")

                processed += 1

            except Exception as e:
                print(f"   ‚ùå Failed: {str(e)}")
                if debug:
                    import traceback
                    traceback.print_exc()
                failed += 1

            print()
        
        # Print summary
        print("üìä Processing Summary:")
        print(f"   ‚úÖ Processed: {processed} files")
        if skipped > 0:
            print(f"   ‚è≠Ô∏è  Skipped: {skipped} files (use --force to overwrite)")
        if failed > 0:
            print(f"   ‚ùå Failed: {failed} files")
        print(f"   üìÅ Output directory: {chordpro_dir}")

        # Add processing summary to log file (insert after header, before data)
        _insert_processing_summary_to_log(summary_log, processed, skipped, failed, chordpro_dir)

        return 0 if failed == 0 else 1

    except Exception as e:
        print(f"‚ùå Error processing language folder: {str(e)}")
        if debug:
            import traceback
            traceback.print_exc()
        return 1


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Parse entire language folders to ChordPro format",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  chordprofolder sl              # Parse all Slovenian PDFs
  chordprofolder hr              # Parse all Croatian PDFs
  chordprofolder sl --verbose    # Parse with detailed output
  chordprofolder hr --force      # Parse and overwrite existing files

Folder Structure:
  git/
  ‚îú‚îÄ‚îÄ lang/
  ‚îÇ   ‚îú‚îÄ‚îÄ sl/
  ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 03_pdf/      (SL - 001.pdf, SL - 002.pdf, ...)
  ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ 04_chordpro/ (SL - 001.chordpro, SL - 002.chordpro, ...)
  ‚îÇ   ‚îî‚îÄ‚îÄ hr/
  ‚îÇ       ‚îú‚îÄ‚îÄ 03_pdf/      (HR - 001.pdf, HR - 002.pdf, ...)
  ‚îÇ       ‚îî‚îÄ‚îÄ 04_chordpro/ (HR - 001.chordpro, HR - 002.chordpro, ...)
  ‚îî‚îÄ‚îÄ parser/              (this script and parser code)
        """
    )
    
    # Required language argument
    parser.add_argument("language", 
                       help="Language code (sl, hr, de, it, es, etc.)")
    
    # Optional arguments
    parser.add_argument("--limit", "-l", type=int, default=None,
                       help="Limit number of files to process (e.g., --limit 20)")
    parser.add_argument("--verbose", "-v", action="store_true",
                       help="Enable verbose output")
    parser.add_argument("--force", "-f", action="store_true",
                       help="Overwrite existing ChordPro files")
    parser.add_argument("--debug", "-d", action="store_true",
                       help="Enable debug logging (very verbose)")
    
    args = parser.parse_args()

    # Setup logging
    setup_logging(args.verbose, args.debug)

    # Process the language folder
    return process_language_folder(args.language, args.verbose, args.force, args.debug, args.limit)


if __name__ == "__main__":
    sys.exit(main())
